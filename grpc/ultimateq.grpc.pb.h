// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ultimateq.proto
#ifndef GRPC_ultimateq_2eproto__INCLUDED
#define GRPC_ultimateq_2eproto__INCLUDED

#include "ultimateq.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class Channel;
class CompletionQueue;
class ServerCompletionQueue;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc_impl

namespace grpc {
class ServerContext;
}  // namespace grpc

namespace api {

class Ext final {
 public:
  static constexpr char const* service_full_name() {
    return "api.Ext";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Events subscribes a client to a specified (or all) events for a given
    // extension. A client can optionally include the ids returned from
    // Register* rpc calls to create a filtered list that will not collide
    // with another extension even of the same name.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::IRCEventResponse>> Events(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::IRCEventResponse>>(EventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::IRCEventResponse>> AsyncEvents(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::IRCEventResponse>>(AsyncEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::IRCEventResponse>> PrepareAsyncEvents(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::IRCEventResponse>>(PrepareAsyncEventsRaw(context, request, cq));
    }
    // Commands is the same as Events above but for Commands.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::CmdEventResponse>> Commands(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::CmdEventResponse>>(CommandsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::CmdEventResponse>> AsyncCommands(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::CmdEventResponse>>(AsyncCommandsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::CmdEventResponse>> PrepareAsyncCommands(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::CmdEventResponse>>(PrepareAsyncCommandsRaw(context, request, cq));
    }
    virtual ::grpc::Status Write(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncWrite(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncWrite(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status Register(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::api::RegisterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>> AsyncRegister(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>>(AsyncRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    virtual ::grpc::Status RegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::api::RegisterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>> AsyncRegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>>(AsyncRegisterCmdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>> PrepareAsyncRegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>>(PrepareAsyncRegisterCmdRaw(context, request, cq));
    }
    virtual ::grpc::Status Unregister(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::api::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> AsyncUnregister(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(AsyncUnregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> PrepareAsyncUnregister(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(PrepareAsyncUnregisterRaw(context, request, cq));
    }
    virtual ::grpc::Status UnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::api::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> AsyncUnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(AsyncUnregisterCmdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> PrepareAsyncUnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(PrepareAsyncUnregisterCmdRaw(context, request, cq));
    }
    virtual ::grpc::Status UnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncUnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncUnregisterAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncUnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncUnregisterAllRaw(context, request, cq));
    }
    // ==================================
    // Data methods
    // ==================================
    virtual ::grpc::Status NetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::api::NetworkInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::NetworkInfo>> AsyncNetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::NetworkInfo>>(AsyncNetworkInformationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::NetworkInfo>> PrepareAsyncNetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::NetworkInfo>>(PrepareAsyncNetworkInformationRaw(context, request, cq));
    }
    virtual ::grpc::Status StateSelf(::grpc::ClientContext* context, const ::api::Query& request, ::api::SelfResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::SelfResponse>> AsyncStateSelf(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::SelfResponse>>(AsyncStateSelfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::SelfResponse>> PrepareAsyncStateSelf(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::SelfResponse>>(PrepareAsyncStateSelfRaw(context, request, cq));
    }
    virtual ::grpc::Status StateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StateUser* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StateUser>> AsyncStateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StateUser>>(AsyncStateUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StateUser>> PrepareAsyncStateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StateUser>>(PrepareAsyncStateUsersRaw(context, request, cq));
    }
    virtual ::grpc::Status StateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::ListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>> AsyncStateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>>(AsyncStateUsersByChanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>> PrepareAsyncStateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>>(PrepareAsyncStateUsersByChanRaw(context, request, cq));
    }
    virtual ::grpc::Status StateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::CountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>> AsyncStateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>>(AsyncStateUsersByChanCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>> PrepareAsyncStateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>>(PrepareAsyncStateUsersByChanCountRaw(context, request, cq));
    }
    virtual ::grpc::Status StateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::api::UserModes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::UserModes>> AsyncStateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::UserModes>>(AsyncStateUserModesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::UserModes>> PrepareAsyncStateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::UserModes>>(PrepareAsyncStateUserModesRaw(context, request, cq));
    }
    virtual ::grpc::Status StateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::ChannelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ChannelResponse>> AsyncStateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ChannelResponse>>(AsyncStateChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ChannelResponse>> PrepareAsyncStateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ChannelResponse>>(PrepareAsyncStateChannelRaw(context, request, cq));
    }
    virtual ::grpc::Status StateChannels(::grpc::ClientContext* context, const ::api::Query& request, ::api::ListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>> AsyncStateChannels(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>>(AsyncStateChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>> PrepareAsyncStateChannels(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>>(PrepareAsyncStateChannelsRaw(context, request, cq));
    }
    virtual ::grpc::Status StateChannelCount(::grpc::ClientContext* context, const ::api::Query& request, ::api::CountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>> AsyncStateChannelCount(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>>(AsyncStateChannelCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>> PrepareAsyncStateChannelCount(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>>(PrepareAsyncStateChannelCountRaw(context, request, cq));
    }
    virtual ::grpc::Status StateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::api::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> AsyncStateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(AsyncStateIsOnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> PrepareAsyncStateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(PrepareAsyncStateIsOnRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::api::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> AsyncStoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(AsyncStoreAuthUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>> PrepareAsyncStoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>>(PrepareAsyncStoreAuthUserRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StoredUser* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>> AsyncStoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>>(AsyncStoreAuthedUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>> PrepareAsyncStoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>>(PrepareAsyncStoreAuthedUserRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreUser(::grpc::ClientContext* context, const ::api::Query& request, ::api::StoredUser* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>> AsyncStoreUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>>(AsyncStoreUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>> PrepareAsyncStoreUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>>(PrepareAsyncStoreUserRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreUsers(::grpc::ClientContext* context, const ::api::Empty& request, ::api::StoredUsersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>> AsyncStoreUsers(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>>(AsyncStoreUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>> PrepareAsyncStoreUsers(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>>(PrepareAsyncStoreUsersRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query& request, ::api::StoredUsersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>> AsyncStoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>>(AsyncStoreUsersByNetworkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>> PrepareAsyncStoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>>(PrepareAsyncStoreUsersByNetworkRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StoredUsersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>> AsyncStoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>>(AsyncStoreUsersByChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>> PrepareAsyncStoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>>(PrepareAsyncStoreUsersByChannelRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StoredChannel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannel>> AsyncStoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannel>>(AsyncStoreChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannel>> PrepareAsyncStoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannel>>(PrepareAsyncStoreChannelRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreChannels(::grpc::ClientContext* context, const ::api::Empty& request, ::api::StoredChannelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannelsResponse>> AsyncStoreChannels(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannelsResponse>>(AsyncStoreChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannelsResponse>> PrepareAsyncStoreChannels(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannelsResponse>>(PrepareAsyncStoreChannelsRaw(context, request, cq));
    }
    virtual ::grpc::Status StorePutUser(::grpc::ClientContext* context, const ::api::StoredUser& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncStorePutUser(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncStorePutUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncStorePutUser(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncStorePutUserRaw(context, request, cq));
    }
    virtual ::grpc::Status StorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncStorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncStorePutChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncStorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncStorePutChannelRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreDeleteUser(::grpc::ClientContext* context, const ::api::Query& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncStoreDeleteUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncStoreDeleteUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncStoreDeleteUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncStoreDeleteUserRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncStoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncStoreDeleteChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncStoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncStoreDeleteChannelRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncStoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncStoreLogoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncStoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncStoreLogoutRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query& request, ::api::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> AsyncStoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(AsyncStoreLogoutByUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>> PrepareAsyncStoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>>(PrepareAsyncStoreLogoutByUserRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Events subscribes a client to a specified (or all) events for a given
      // extension. A client can optionally include the ids returned from
      // Register* rpc calls to create a filtered list that will not collide
      // with another extension even of the same name.
      virtual void Events(::grpc::ClientContext* context, ::api::SubscriptionRequest* request, ::grpc::experimental::ClientReadReactor< ::api::IRCEventResponse>* reactor) = 0;
      // Commands is the same as Events above but for Commands.
      virtual void Commands(::grpc::ClientContext* context, ::api::SubscriptionRequest* request, ::grpc::experimental::ClientReadReactor< ::api::CmdEventResponse>* reactor) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::api::WriteRequest* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::api::WriteRequest* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Register(::grpc::ClientContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Register(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Register(::grpc::ClientContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Register(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RegisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Unregister(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unregister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unregister(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Unregister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnregisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UnregisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnregisterAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UnregisterAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ==================================
      // Data methods
      // ==================================
      virtual void NetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NetworkInformation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::NetworkInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NetworkInformation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateSelf(::grpc::ClientContext* context, const ::api::Query* request, ::api::SelfResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateSelf(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::SelfResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateSelf(::grpc::ClientContext* context, const ::api::Query* request, ::api::SelfResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateSelf(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::SelfResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StateUser* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StateUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUsersByChan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUsersByChan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUsersByChanCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUsersByChanCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUserModes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::UserModes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateUserModes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::UserModes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateChannels(::grpc::ClientContext* context, const ::api::Query* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateChannels(::grpc::ClientContext* context, const ::api::Query* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateChannelCount(::grpc::ClientContext* context, const ::api::Query* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateChannelCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateChannelCount(::grpc::ClientContext* context, const ::api::Query* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateChannelCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateIsOn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StateIsOn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreAuthUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreAuthUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreAuthedUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreAuthedUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUsers(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUsers(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUsersByNetwork(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUsersByNetwork(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUsersByChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreUsersByChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannel* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreChannels(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreChannels(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StorePutUser(::grpc::ClientContext* context, const ::api::StoredUser* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StorePutUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StorePutUser(::grpc::ClientContext* context, const ::api::StoredUser* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StorePutUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StorePutChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StorePutChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreDeleteUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreDeleteUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreDeleteUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreDeleteUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreDeleteChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreDeleteChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreLogout(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreLogout(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreLogoutByUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreLogoutByUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::api::IRCEventResponse>* EventsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::IRCEventResponse>* AsyncEventsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::IRCEventResponse>* PrepareAsyncEventsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::CmdEventResponse>* CommandsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::CmdEventResponse>* AsyncCommandsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::CmdEventResponse>* PrepareAsyncCommandsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncWriteRaw(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>* AsyncRegisterCmdRaw(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::RegisterResponse>* PrepareAsyncRegisterCmdRaw(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* AsyncUnregisterRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* PrepareAsyncUnregisterRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* AsyncUnregisterCmdRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* PrepareAsyncUnregisterCmdRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncUnregisterAllRaw(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncUnregisterAllRaw(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::NetworkInfo>* AsyncNetworkInformationRaw(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::NetworkInfo>* PrepareAsyncNetworkInformationRaw(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::SelfResponse>* AsyncStateSelfRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::SelfResponse>* PrepareAsyncStateSelfRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StateUser>* AsyncStateUsersRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StateUser>* PrepareAsyncStateUsersRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>* AsyncStateUsersByChanRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>* PrepareAsyncStateUsersByChanRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>* AsyncStateUsersByChanCountRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>* PrepareAsyncStateUsersByChanCountRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::UserModes>* AsyncStateUserModesRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::UserModes>* PrepareAsyncStateUserModesRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::ChannelResponse>* AsyncStateChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::ChannelResponse>* PrepareAsyncStateChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>* AsyncStateChannelsRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::ListResponse>* PrepareAsyncStateChannelsRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>* AsyncStateChannelCountRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::CountResponse>* PrepareAsyncStateChannelCountRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* AsyncStateIsOnRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* PrepareAsyncStateIsOnRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* AsyncStoreAuthUserRaw(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Result>* PrepareAsyncStoreAuthUserRaw(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>* AsyncStoreAuthedUserRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>* PrepareAsyncStoreAuthedUserRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>* AsyncStoreUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUser>* PrepareAsyncStoreUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>* AsyncStoreUsersRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>* PrepareAsyncStoreUsersRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>* AsyncStoreUsersByNetworkRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>* PrepareAsyncStoreUsersByNetworkRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>* AsyncStoreUsersByChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredUsersResponse>* PrepareAsyncStoreUsersByChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannel>* AsyncStoreChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannel>* PrepareAsyncStoreChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannelsResponse>* AsyncStoreChannelsRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::StoredChannelsResponse>* PrepareAsyncStoreChannelsRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncStorePutUserRaw(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncStorePutUserRaw(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncStorePutChannelRaw(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncStorePutChannelRaw(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncStoreDeleteUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncStoreDeleteUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncStoreDeleteChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncStoreDeleteChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncStoreLogoutRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncStoreLogoutRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* AsyncStoreLogoutByUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::Empty>* PrepareAsyncStoreLogoutByUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::api::IRCEventResponse>> Events(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::IRCEventResponse>>(EventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::IRCEventResponse>> AsyncEvents(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::IRCEventResponse>>(AsyncEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::IRCEventResponse>> PrepareAsyncEvents(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::IRCEventResponse>>(PrepareAsyncEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::CmdEventResponse>> Commands(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::CmdEventResponse>>(CommandsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::CmdEventResponse>> AsyncCommands(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::CmdEventResponse>>(AsyncCommandsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::CmdEventResponse>> PrepareAsyncCommands(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::CmdEventResponse>>(PrepareAsyncCommandsRaw(context, request, cq));
    }
    ::grpc::Status Write(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncWrite(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncWrite(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncWriteRaw(context, request, cq));
    }
    ::grpc::Status Register(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::api::RegisterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>> AsyncRegister(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>>(AsyncRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    ::grpc::Status RegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::api::RegisterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>> AsyncRegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>>(AsyncRegisterCmdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>> PrepareAsyncRegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>>(PrepareAsyncRegisterCmdRaw(context, request, cq));
    }
    ::grpc::Status Unregister(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::api::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> AsyncUnregister(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(AsyncUnregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> PrepareAsyncUnregister(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(PrepareAsyncUnregisterRaw(context, request, cq));
    }
    ::grpc::Status UnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::api::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> AsyncUnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(AsyncUnregisterCmdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> PrepareAsyncUnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(PrepareAsyncUnregisterCmdRaw(context, request, cq));
    }
    ::grpc::Status UnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncUnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncUnregisterAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncUnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncUnregisterAllRaw(context, request, cq));
    }
    ::grpc::Status NetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::api::NetworkInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::NetworkInfo>> AsyncNetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::NetworkInfo>>(AsyncNetworkInformationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::NetworkInfo>> PrepareAsyncNetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::NetworkInfo>>(PrepareAsyncNetworkInformationRaw(context, request, cq));
    }
    ::grpc::Status StateSelf(::grpc::ClientContext* context, const ::api::Query& request, ::api::SelfResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::SelfResponse>> AsyncStateSelf(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::SelfResponse>>(AsyncStateSelfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::SelfResponse>> PrepareAsyncStateSelf(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::SelfResponse>>(PrepareAsyncStateSelfRaw(context, request, cq));
    }
    ::grpc::Status StateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StateUser* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StateUser>> AsyncStateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StateUser>>(AsyncStateUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StateUser>> PrepareAsyncStateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StateUser>>(PrepareAsyncStateUsersRaw(context, request, cq));
    }
    ::grpc::Status StateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::ListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>> AsyncStateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>>(AsyncStateUsersByChanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>> PrepareAsyncStateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>>(PrepareAsyncStateUsersByChanRaw(context, request, cq));
    }
    ::grpc::Status StateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::CountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>> AsyncStateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>>(AsyncStateUsersByChanCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>> PrepareAsyncStateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>>(PrepareAsyncStateUsersByChanCountRaw(context, request, cq));
    }
    ::grpc::Status StateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::api::UserModes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::UserModes>> AsyncStateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::UserModes>>(AsyncStateUserModesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::UserModes>> PrepareAsyncStateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::UserModes>>(PrepareAsyncStateUserModesRaw(context, request, cq));
    }
    ::grpc::Status StateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::ChannelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ChannelResponse>> AsyncStateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ChannelResponse>>(AsyncStateChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ChannelResponse>> PrepareAsyncStateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ChannelResponse>>(PrepareAsyncStateChannelRaw(context, request, cq));
    }
    ::grpc::Status StateChannels(::grpc::ClientContext* context, const ::api::Query& request, ::api::ListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>> AsyncStateChannels(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>>(AsyncStateChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>> PrepareAsyncStateChannels(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::ListResponse>>(PrepareAsyncStateChannelsRaw(context, request, cq));
    }
    ::grpc::Status StateChannelCount(::grpc::ClientContext* context, const ::api::Query& request, ::api::CountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>> AsyncStateChannelCount(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>>(AsyncStateChannelCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>> PrepareAsyncStateChannelCount(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::CountResponse>>(PrepareAsyncStateChannelCountRaw(context, request, cq));
    }
    ::grpc::Status StateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::api::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> AsyncStateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(AsyncStateIsOnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> PrepareAsyncStateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(PrepareAsyncStateIsOnRaw(context, request, cq));
    }
    ::grpc::Status StoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::api::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> AsyncStoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(AsyncStoreAuthUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>> PrepareAsyncStoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Result>>(PrepareAsyncStoreAuthUserRaw(context, request, cq));
    }
    ::grpc::Status StoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StoredUser* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>> AsyncStoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>>(AsyncStoreAuthedUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>> PrepareAsyncStoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>>(PrepareAsyncStoreAuthedUserRaw(context, request, cq));
    }
    ::grpc::Status StoreUser(::grpc::ClientContext* context, const ::api::Query& request, ::api::StoredUser* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>> AsyncStoreUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>>(AsyncStoreUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>> PrepareAsyncStoreUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUser>>(PrepareAsyncStoreUserRaw(context, request, cq));
    }
    ::grpc::Status StoreUsers(::grpc::ClientContext* context, const ::api::Empty& request, ::api::StoredUsersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>> AsyncStoreUsers(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>>(AsyncStoreUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>> PrepareAsyncStoreUsers(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>>(PrepareAsyncStoreUsersRaw(context, request, cq));
    }
    ::grpc::Status StoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query& request, ::api::StoredUsersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>> AsyncStoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>>(AsyncStoreUsersByNetworkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>> PrepareAsyncStoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>>(PrepareAsyncStoreUsersByNetworkRaw(context, request, cq));
    }
    ::grpc::Status StoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StoredUsersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>> AsyncStoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>>(AsyncStoreUsersByChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>> PrepareAsyncStoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>>(PrepareAsyncStoreUsersByChannelRaw(context, request, cq));
    }
    ::grpc::Status StoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::StoredChannel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannel>> AsyncStoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannel>>(AsyncStoreChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannel>> PrepareAsyncStoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannel>>(PrepareAsyncStoreChannelRaw(context, request, cq));
    }
    ::grpc::Status StoreChannels(::grpc::ClientContext* context, const ::api::Empty& request, ::api::StoredChannelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannelsResponse>> AsyncStoreChannels(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannelsResponse>>(AsyncStoreChannelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannelsResponse>> PrepareAsyncStoreChannels(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::StoredChannelsResponse>>(PrepareAsyncStoreChannelsRaw(context, request, cq));
    }
    ::grpc::Status StorePutUser(::grpc::ClientContext* context, const ::api::StoredUser& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncStorePutUser(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncStorePutUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncStorePutUser(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncStorePutUserRaw(context, request, cq));
    }
    ::grpc::Status StorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncStorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncStorePutChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncStorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncStorePutChannelRaw(context, request, cq));
    }
    ::grpc::Status StoreDeleteUser(::grpc::ClientContext* context, const ::api::Query& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncStoreDeleteUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncStoreDeleteUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncStoreDeleteUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncStoreDeleteUserRaw(context, request, cq));
    }
    ::grpc::Status StoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncStoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncStoreDeleteChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncStoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncStoreDeleteChannelRaw(context, request, cq));
    }
    ::grpc::Status StoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncStoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncStoreLogoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncStoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncStoreLogoutRaw(context, request, cq));
    }
    ::grpc::Status StoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query& request, ::api::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> AsyncStoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(AsyncStoreLogoutByUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>> PrepareAsyncStoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::Empty>>(PrepareAsyncStoreLogoutByUserRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Events(::grpc::ClientContext* context, ::api::SubscriptionRequest* request, ::grpc::experimental::ClientReadReactor< ::api::IRCEventResponse>* reactor) override;
      void Commands(::grpc::ClientContext* context, ::api::SubscriptionRequest* request, ::grpc::experimental::ClientReadReactor< ::api::CmdEventResponse>* reactor) override;
      void Write(::grpc::ClientContext* context, const ::api::WriteRequest* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void Write(::grpc::ClientContext* context, const ::api::WriteRequest* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Register(::grpc::ClientContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void Register(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void Register(::grpc::ClientContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Register(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void RegisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void RegisterCmd(::grpc::ClientContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RegisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::RegisterResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Unregister(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void Unregister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void Unregister(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Unregister(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void UnregisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void UnregisterCmd(::grpc::ClientContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UnregisterCmd(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void UnregisterAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void UnregisterAll(::grpc::ClientContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UnregisterAll(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response, std::function<void(::grpc::Status)>) override;
      void NetworkInformation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::NetworkInfo* response, std::function<void(::grpc::Status)>) override;
      void NetworkInformation(::grpc::ClientContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NetworkInformation(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::NetworkInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateSelf(::grpc::ClientContext* context, const ::api::Query* request, ::api::SelfResponse* response, std::function<void(::grpc::Status)>) override;
      void StateSelf(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::SelfResponse* response, std::function<void(::grpc::Status)>) override;
      void StateSelf(::grpc::ClientContext* context, const ::api::Query* request, ::api::SelfResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateSelf(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::SelfResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response, std::function<void(::grpc::Status)>) override;
      void StateUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StateUser* response, std::function<void(::grpc::Status)>) override;
      void StateUsers(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StateUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) override;
      void StateUsersByChan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) override;
      void StateUsersByChan(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUsersByChan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) override;
      void StateUsersByChanCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) override;
      void StateUsersByChanCount(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUsersByChanCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response, std::function<void(::grpc::Status)>) override;
      void StateUserModes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::UserModes* response, std::function<void(::grpc::Status)>) override;
      void StateUserModes(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateUserModes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::UserModes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void StateChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void StateChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ChannelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateChannels(::grpc::ClientContext* context, const ::api::Query* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) override;
      void StateChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, std::function<void(::grpc::Status)>) override;
      void StateChannels(::grpc::ClientContext* context, const ::api::Query* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateChannelCount(::grpc::ClientContext* context, const ::api::Query* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) override;
      void StateChannelCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, std::function<void(::grpc::Status)>) override;
      void StateChannelCount(::grpc::ClientContext* context, const ::api::Query* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateChannelCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::CountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void StateIsOn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void StateIsOn(::grpc::ClientContext* context, const ::api::ChannelQuery* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StateIsOn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void StoreAuthUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, std::function<void(::grpc::Status)>) override;
      void StoreAuthUser(::grpc::ClientContext* context, const ::api::AuthUserRequest* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreAuthUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Result* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) override;
      void StoreAuthedUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) override;
      void StoreAuthedUser(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreAuthedUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) override;
      void StoreUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, std::function<void(::grpc::Status)>) override;
      void StoreUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUser* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUsers(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreUsers(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUsers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreUsersByNetwork(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreUsersByNetwork(::grpc::ClientContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUsersByNetwork(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreUsersByChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreUsersByChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreUsersByChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response, std::function<void(::grpc::Status)>) override;
      void StoreChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannel* response, std::function<void(::grpc::Status)>) override;
      void StoreChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannel* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreChannels(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannelsResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreChannels(::grpc::ClientContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreChannels(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::StoredChannelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StorePutUser(::grpc::ClientContext* context, const ::api::StoredUser* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StorePutUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StorePutUser(::grpc::ClientContext* context, const ::api::StoredUser* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StorePutUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StorePutChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StorePutChannel(::grpc::ClientContext* context, const ::api::StoredChannel* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StorePutChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreDeleteUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreDeleteUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreDeleteUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreDeleteUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreDeleteChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreDeleteChannel(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreDeleteChannel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreLogout(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreLogout(::grpc::ClientContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreLogout(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreLogoutByUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, std::function<void(::grpc::Status)>) override;
      void StoreLogoutByUser(::grpc::ClientContext* context, const ::api::Query* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreLogoutByUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::api::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::api::IRCEventResponse>* EventsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::IRCEventResponse>* AsyncEventsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::IRCEventResponse>* PrepareAsyncEventsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::CmdEventResponse>* CommandsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::CmdEventResponse>* AsyncCommandsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::CmdEventResponse>* PrepareAsyncCommandsRaw(::grpc::ClientContext* context, const ::api::SubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncWriteRaw(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::api::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::api::RegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>* AsyncRegisterCmdRaw(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::RegisterResponse>* PrepareAsyncRegisterCmdRaw(::grpc::ClientContext* context, const ::api::RegisterCmdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* AsyncUnregisterRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* PrepareAsyncUnregisterRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* AsyncUnregisterCmdRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* PrepareAsyncUnregisterCmdRaw(::grpc::ClientContext* context, const ::api::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncUnregisterAllRaw(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncUnregisterAllRaw(::grpc::ClientContext* context, const ::api::UnregisterAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::NetworkInfo>* AsyncNetworkInformationRaw(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::NetworkInfo>* PrepareAsyncNetworkInformationRaw(::grpc::ClientContext* context, const ::api::NetworkInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::SelfResponse>* AsyncStateSelfRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::SelfResponse>* PrepareAsyncStateSelfRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StateUser>* AsyncStateUsersRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StateUser>* PrepareAsyncStateUsersRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::ListResponse>* AsyncStateUsersByChanRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::ListResponse>* PrepareAsyncStateUsersByChanRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::CountResponse>* AsyncStateUsersByChanCountRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::CountResponse>* PrepareAsyncStateUsersByChanCountRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::UserModes>* AsyncStateUserModesRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::UserModes>* PrepareAsyncStateUserModesRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::ChannelResponse>* AsyncStateChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::ChannelResponse>* PrepareAsyncStateChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::ListResponse>* AsyncStateChannelsRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::ListResponse>* PrepareAsyncStateChannelsRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::CountResponse>* AsyncStateChannelCountRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::CountResponse>* PrepareAsyncStateChannelCountRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* AsyncStateIsOnRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* PrepareAsyncStateIsOnRaw(::grpc::ClientContext* context, const ::api::ChannelQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* AsyncStoreAuthUserRaw(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Result>* PrepareAsyncStoreAuthUserRaw(::grpc::ClientContext* context, const ::api::AuthUserRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUser>* AsyncStoreAuthedUserRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUser>* PrepareAsyncStoreAuthedUserRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUser>* AsyncStoreUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUser>* PrepareAsyncStoreUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>* AsyncStoreUsersRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>* PrepareAsyncStoreUsersRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>* AsyncStoreUsersByNetworkRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>* PrepareAsyncStoreUsersByNetworkRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>* AsyncStoreUsersByChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredUsersResponse>* PrepareAsyncStoreUsersByChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredChannel>* AsyncStoreChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredChannel>* PrepareAsyncStoreChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredChannelsResponse>* AsyncStoreChannelsRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::StoredChannelsResponse>* PrepareAsyncStoreChannelsRaw(::grpc::ClientContext* context, const ::api::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncStorePutUserRaw(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncStorePutUserRaw(::grpc::ClientContext* context, const ::api::StoredUser& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncStorePutChannelRaw(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncStorePutChannelRaw(::grpc::ClientContext* context, const ::api::StoredChannel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncStoreDeleteUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncStoreDeleteUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncStoreDeleteChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncStoreDeleteChannelRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncStoreLogoutRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncStoreLogoutRaw(::grpc::ClientContext* context, const ::api::NetworkQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* AsyncStoreLogoutByUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::Empty>* PrepareAsyncStoreLogoutByUserRaw(::grpc::ClientContext* context, const ::api::Query& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Events_;
    const ::grpc::internal::RpcMethod rpcmethod_Commands_;
    const ::grpc::internal::RpcMethod rpcmethod_Write_;
    const ::grpc::internal::RpcMethod rpcmethod_Register_;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterCmd_;
    const ::grpc::internal::RpcMethod rpcmethod_Unregister_;
    const ::grpc::internal::RpcMethod rpcmethod_UnregisterCmd_;
    const ::grpc::internal::RpcMethod rpcmethod_UnregisterAll_;
    const ::grpc::internal::RpcMethod rpcmethod_NetworkInformation_;
    const ::grpc::internal::RpcMethod rpcmethod_StateSelf_;
    const ::grpc::internal::RpcMethod rpcmethod_StateUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_StateUsersByChan_;
    const ::grpc::internal::RpcMethod rpcmethod_StateUsersByChanCount_;
    const ::grpc::internal::RpcMethod rpcmethod_StateUserModes_;
    const ::grpc::internal::RpcMethod rpcmethod_StateChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_StateChannels_;
    const ::grpc::internal::RpcMethod rpcmethod_StateChannelCount_;
    const ::grpc::internal::RpcMethod rpcmethod_StateIsOn_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreAuthUser_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreAuthedUser_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreUser_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreUsersByNetwork_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreUsersByChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreChannels_;
    const ::grpc::internal::RpcMethod rpcmethod_StorePutUser_;
    const ::grpc::internal::RpcMethod rpcmethod_StorePutChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreDeleteUser_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreDeleteChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreLogout_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreLogoutByUser_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Events subscribes a client to a specified (or all) events for a given
    // extension. A client can optionally include the ids returned from
    // Register* rpc calls to create a filtered list that will not collide
    // with another extension even of the same name.
    virtual ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer);
    // Commands is the same as Events above but for Commands.
    virtual ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer);
    virtual ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response);
    virtual ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response);
    virtual ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response);
    virtual ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response);
    virtual ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response);
    virtual ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response);
    // ==================================
    // Data methods
    // ==================================
    virtual ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response);
    virtual ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response);
    virtual ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response);
    virtual ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response);
    virtual ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response);
    virtual ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response);
    virtual ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response);
    virtual ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response);
    virtual ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response);
    virtual ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response);
    virtual ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response);
    virtual ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response);
    virtual ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response);
    virtual ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response);
    virtual ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response);
    virtual ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response);
    virtual ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response);
    virtual ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response);
    virtual ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response);
    virtual ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response);
    virtual ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response);
    virtual ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response);
    virtual ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response);
    virtual ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Events() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvents(::grpc::ServerContext* context, ::api::SubscriptionRequest* request, ::grpc::ServerAsyncWriter< ::api::IRCEventResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Commands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Commands() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Commands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommands(::grpc::ServerContext* context, ::api::SubscriptionRequest* request, ::grpc::ServerAsyncWriter< ::api::CmdEventResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Write() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWrite(::grpc::ServerContext* context, ::api::WriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Register() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::api::RegisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::RegisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RegisterCmd() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_RegisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterCmd(::grpc::ServerContext* context, ::api::RegisterCmdRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::RegisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unregister() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregister(::grpc::ServerContext* context, ::api::UnregisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnregisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UnregisterCmd() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UnregisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregisterCmd(::grpc::ServerContext* context, ::api::UnregisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnregisterAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UnregisterAll() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_UnregisterAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregisterAll(::grpc::ServerContext* context, ::api::UnregisterAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NetworkInformation() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_NetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetworkInformation(::grpc::ServerContext* context, ::api::NetworkInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::NetworkInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateSelf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateSelf() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_StateSelf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateSelf(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::SelfResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateUsers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_StateUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUsers(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::StateUser>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateUsersByChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateUsersByChan() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_StateUsersByChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUsersByChan(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::ListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateUsersByChanCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateUsersByChanCount() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_StateUsersByChanCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUsersByChanCount(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::CountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateUserModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateUserModes() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_StateUserModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUserModes(::grpc::ServerContext* context, ::api::ChannelQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::UserModes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateChannel() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_StateChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateChannel(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::ChannelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateChannels() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_StateChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateChannels(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::ListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateChannelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateChannelCount() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_StateChannelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateChannelCount(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::CountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StateIsOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StateIsOn() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_StateIsOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateIsOn(::grpc::ServerContext* context, ::api::ChannelQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreAuthUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreAuthUser() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_StoreAuthUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreAuthUser(::grpc::ServerContext* context, ::api::AuthUserRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreAuthedUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreAuthedUser() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_StoreAuthedUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreAuthedUser(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredUser>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreUser() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_StoreUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUser(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredUser>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreUsers() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_StoreUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUsers(::grpc::ServerContext* context, ::api::Empty* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredUsersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreUsersByNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreUsersByNetwork() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_StoreUsersByNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUsersByNetwork(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredUsersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreUsersByChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreUsersByChannel() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_StoreUsersByChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUsersByChannel(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredUsersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreChannel() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_StoreChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreChannel(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredChannel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreChannels() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_StoreChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreChannels(::grpc::ServerContext* context, ::api::Empty* request, ::grpc::ServerAsyncResponseWriter< ::api::StoredChannelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StorePutUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StorePutUser() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_StorePutUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStorePutUser(::grpc::ServerContext* context, ::api::StoredUser* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StorePutChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StorePutChannel() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_StorePutChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStorePutChannel(::grpc::ServerContext* context, ::api::StoredChannel* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreDeleteUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreDeleteUser() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_StoreDeleteUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreDeleteUser(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreDeleteChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreDeleteChannel() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_StoreDeleteChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreDeleteChannel(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreLogout() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_StoreLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreLogout(::grpc::ServerContext* context, ::api::NetworkQuery* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreLogoutByUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StoreLogoutByUser() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_StoreLogoutByUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreLogoutByUser(::grpc::ServerContext* context, ::api::Query* request, ::grpc::ServerAsyncResponseWriter< ::api::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Events<WithAsyncMethod_Commands<WithAsyncMethod_Write<WithAsyncMethod_Register<WithAsyncMethod_RegisterCmd<WithAsyncMethod_Unregister<WithAsyncMethod_UnregisterCmd<WithAsyncMethod_UnregisterAll<WithAsyncMethod_NetworkInformation<WithAsyncMethod_StateSelf<WithAsyncMethod_StateUsers<WithAsyncMethod_StateUsersByChan<WithAsyncMethod_StateUsersByChanCount<WithAsyncMethod_StateUserModes<WithAsyncMethod_StateChannel<WithAsyncMethod_StateChannels<WithAsyncMethod_StateChannelCount<WithAsyncMethod_StateIsOn<WithAsyncMethod_StoreAuthUser<WithAsyncMethod_StoreAuthedUser<WithAsyncMethod_StoreUser<WithAsyncMethod_StoreUsers<WithAsyncMethod_StoreUsersByNetwork<WithAsyncMethod_StoreUsersByChannel<WithAsyncMethod_StoreChannel<WithAsyncMethod_StoreChannels<WithAsyncMethod_StorePutUser<WithAsyncMethod_StorePutChannel<WithAsyncMethod_StoreDeleteUser<WithAsyncMethod_StoreDeleteChannel<WithAsyncMethod_StoreLogout<WithAsyncMethod_StoreLogoutByUser<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Events() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackServerStreamingHandler< ::api::SubscriptionRequest, ::api::IRCEventResponse>(
          [this] { return this->Events(); }));
    }
    ~ExperimentalWithCallbackMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::api::SubscriptionRequest, ::api::IRCEventResponse>* Events() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::api::SubscriptionRequest, ::api::IRCEventResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Commands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Commands() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackServerStreamingHandler< ::api::SubscriptionRequest, ::api::CmdEventResponse>(
          [this] { return this->Commands(); }));
    }
    ~ExperimentalWithCallbackMethod_Commands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::api::SubscriptionRequest, ::api::CmdEventResponse>* Commands() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::api::SubscriptionRequest, ::api::CmdEventResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Write() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::api::WriteRequest, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::WriteRequest* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Write(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Write(
        ::grpc::experimental::MessageAllocator< ::api::WriteRequest, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::WriteRequest, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Register() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::api::RegisterRequest, ::api::RegisterResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::RegisterRequest* request,
                 ::api::RegisterResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Register(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Register(
        ::grpc::experimental::MessageAllocator< ::api::RegisterRequest, ::api::RegisterResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::RegisterRequest, ::api::RegisterResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RegisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_RegisterCmd() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::api::RegisterCmdRequest, ::api::RegisterResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::RegisterCmdRequest* request,
                 ::api::RegisterResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->RegisterCmd(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_RegisterCmd(
        ::grpc::experimental::MessageAllocator< ::api::RegisterCmdRequest, ::api::RegisterResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::RegisterCmdRequest, ::api::RegisterResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RegisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Unregister() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::api::UnregisterRequest, ::api::Result>(
          [this](::grpc::ServerContext* context,
                 const ::api::UnregisterRequest* request,
                 ::api::Result* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Unregister(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Unregister(
        ::grpc::experimental::MessageAllocator< ::api::UnregisterRequest, ::api::Result>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::UnregisterRequest, ::api::Result>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnregisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UnregisterCmd() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::api::UnregisterRequest, ::api::Result>(
          [this](::grpc::ServerContext* context,
                 const ::api::UnregisterRequest* request,
                 ::api::Result* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UnregisterCmd(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UnregisterCmd(
        ::grpc::experimental::MessageAllocator< ::api::UnregisterRequest, ::api::Result>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::UnregisterRequest, ::api::Result>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnregisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnregisterAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UnregisterAll() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::api::UnregisterAllRequest, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::UnregisterAllRequest* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UnregisterAll(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UnregisterAll(
        ::grpc::experimental::MessageAllocator< ::api::UnregisterAllRequest, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::UnregisterAllRequest, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnregisterAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NetworkInformation() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkInfoRequest, ::api::NetworkInfo>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkInfoRequest* request,
                 ::api::NetworkInfo* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NetworkInformation(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NetworkInformation(
        ::grpc::experimental::MessageAllocator< ::api::NetworkInfoRequest, ::api::NetworkInfo>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkInfoRequest, ::api::NetworkInfo>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateSelf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateSelf() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::SelfResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::SelfResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateSelf(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateSelf(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::SelfResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::SelfResponse>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateSelf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateUsers() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StateUser>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::StateUser* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateUsers(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateUsers(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::StateUser>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StateUser>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateUsersByChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateUsersByChan() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::ListResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::ListResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateUsersByChan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateUsersByChan(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::ListResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::ListResponse>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateUsersByChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateUsersByChanCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateUsersByChanCount() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::CountResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::CountResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateUsersByChanCount(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateUsersByChanCount(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::CountResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::CountResponse>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateUsersByChanCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateUserModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateUserModes() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::api::ChannelQuery, ::api::UserModes>(
          [this](::grpc::ServerContext* context,
                 const ::api::ChannelQuery* request,
                 ::api::UserModes* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateUserModes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateUserModes(
        ::grpc::experimental::MessageAllocator< ::api::ChannelQuery, ::api::UserModes>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::ChannelQuery, ::api::UserModes>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateUserModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateChannel() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::ChannelResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::ChannelResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateChannel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateChannel(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::ChannelResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::ChannelResponse>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateChannels() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::ListResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::ListResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateChannels(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateChannels(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::ListResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::ListResponse>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateChannelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateChannelCount() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::CountResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::CountResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateChannelCount(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateChannelCount(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::CountResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::CountResponse>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateChannelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StateIsOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StateIsOn() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::api::ChannelQuery, ::api::Result>(
          [this](::grpc::ServerContext* context,
                 const ::api::ChannelQuery* request,
                 ::api::Result* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StateIsOn(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StateIsOn(
        ::grpc::experimental::MessageAllocator< ::api::ChannelQuery, ::api::Result>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::ChannelQuery, ::api::Result>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StateIsOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreAuthUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreAuthUser() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::api::AuthUserRequest, ::api::Result>(
          [this](::grpc::ServerContext* context,
                 const ::api::AuthUserRequest* request,
                 ::api::Result* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreAuthUser(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreAuthUser(
        ::grpc::experimental::MessageAllocator< ::api::AuthUserRequest, ::api::Result>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::AuthUserRequest, ::api::Result>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreAuthUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreAuthedUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreAuthedUser() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StoredUser>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::StoredUser* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreAuthedUser(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreAuthedUser(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::StoredUser>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StoredUser>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreAuthedUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreUser() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::StoredUser>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::StoredUser* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreUser(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreUser(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::StoredUser>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::StoredUser>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreUsers() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Empty, ::api::StoredUsersResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::Empty* request,
                 ::api::StoredUsersResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreUsers(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreUsers(
        ::grpc::experimental::MessageAllocator< ::api::Empty, ::api::StoredUsersResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Empty, ::api::StoredUsersResponse>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreUsersByNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreUsersByNetwork() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::StoredUsersResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::StoredUsersResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreUsersByNetwork(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreUsersByNetwork(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::StoredUsersResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::StoredUsersResponse>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreUsersByNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreUsersByChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreUsersByChannel() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StoredUsersResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::StoredUsersResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreUsersByChannel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreUsersByChannel(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::StoredUsersResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StoredUsersResponse>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreUsersByChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreChannel() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StoredChannel>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::StoredChannel* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreChannel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreChannel(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::StoredChannel>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::StoredChannel>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreChannels() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Empty, ::api::StoredChannelsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::api::Empty* request,
                 ::api::StoredChannelsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreChannels(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreChannels(
        ::grpc::experimental::MessageAllocator< ::api::Empty, ::api::StoredChannelsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Empty, ::api::StoredChannelsResponse>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StorePutUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StorePutUser() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc::internal::CallbackUnaryHandler< ::api::StoredUser, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::StoredUser* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StorePutUser(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StorePutUser(
        ::grpc::experimental::MessageAllocator< ::api::StoredUser, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::StoredUser, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StorePutUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StorePutChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StorePutChannel() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc::internal::CallbackUnaryHandler< ::api::StoredChannel, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::StoredChannel* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StorePutChannel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StorePutChannel(
        ::grpc::experimental::MessageAllocator< ::api::StoredChannel, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::StoredChannel, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StorePutChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreDeleteUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreDeleteUser() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreDeleteUser(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreDeleteUser(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreDeleteUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreDeleteChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreDeleteChannel() {
      ::grpc::Service::experimental().MarkMethodCallback(29,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreDeleteChannel(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreDeleteChannel(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(29))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreDeleteChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreLogout() {
      ::grpc::Service::experimental().MarkMethodCallback(30,
        new ::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::NetworkQuery* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreLogout(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreLogout(
        ::grpc::experimental::MessageAllocator< ::api::NetworkQuery, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::NetworkQuery, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(30))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreLogoutByUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StoreLogoutByUser() {
      ::grpc::Service::experimental().MarkMethodCallback(31,
        new ::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::Empty>(
          [this](::grpc::ServerContext* context,
                 const ::api::Query* request,
                 ::api::Empty* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreLogoutByUser(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreLogoutByUser(
        ::grpc::experimental::MessageAllocator< ::api::Query, ::api::Empty>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::Query, ::api::Empty>*>(
          ::grpc::Service::experimental().GetHandler(31))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreLogoutByUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Events<ExperimentalWithCallbackMethod_Commands<ExperimentalWithCallbackMethod_Write<ExperimentalWithCallbackMethod_Register<ExperimentalWithCallbackMethod_RegisterCmd<ExperimentalWithCallbackMethod_Unregister<ExperimentalWithCallbackMethod_UnregisterCmd<ExperimentalWithCallbackMethod_UnregisterAll<ExperimentalWithCallbackMethod_NetworkInformation<ExperimentalWithCallbackMethod_StateSelf<ExperimentalWithCallbackMethod_StateUsers<ExperimentalWithCallbackMethod_StateUsersByChan<ExperimentalWithCallbackMethod_StateUsersByChanCount<ExperimentalWithCallbackMethod_StateUserModes<ExperimentalWithCallbackMethod_StateChannel<ExperimentalWithCallbackMethod_StateChannels<ExperimentalWithCallbackMethod_StateChannelCount<ExperimentalWithCallbackMethod_StateIsOn<ExperimentalWithCallbackMethod_StoreAuthUser<ExperimentalWithCallbackMethod_StoreAuthedUser<ExperimentalWithCallbackMethod_StoreUser<ExperimentalWithCallbackMethod_StoreUsers<ExperimentalWithCallbackMethod_StoreUsersByNetwork<ExperimentalWithCallbackMethod_StoreUsersByChannel<ExperimentalWithCallbackMethod_StoreChannel<ExperimentalWithCallbackMethod_StoreChannels<ExperimentalWithCallbackMethod_StorePutUser<ExperimentalWithCallbackMethod_StorePutChannel<ExperimentalWithCallbackMethod_StoreDeleteUser<ExperimentalWithCallbackMethod_StoreDeleteChannel<ExperimentalWithCallbackMethod_StoreLogout<ExperimentalWithCallbackMethod_StoreLogoutByUser<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Events() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Commands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Commands() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Commands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Write() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Register() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RegisterCmd() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_RegisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unregister() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnregisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UnregisterCmd() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UnregisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnregisterAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UnregisterAll() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_UnregisterAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NetworkInformation() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_NetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateSelf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateSelf() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_StateSelf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateUsers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_StateUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateUsersByChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateUsersByChan() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_StateUsersByChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateUsersByChanCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateUsersByChanCount() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_StateUsersByChanCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateUserModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateUserModes() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_StateUserModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateChannel() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_StateChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateChannels() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_StateChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateChannelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateChannelCount() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_StateChannelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StateIsOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StateIsOn() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_StateIsOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreAuthUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreAuthUser() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_StoreAuthUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreAuthedUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreAuthedUser() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_StoreAuthedUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreUser() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_StoreUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreUsers() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_StoreUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreUsersByNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreUsersByNetwork() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_StoreUsersByNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreUsersByChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreUsersByChannel() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_StoreUsersByChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreChannel() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_StoreChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreChannels() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_StoreChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StorePutUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StorePutUser() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_StorePutUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StorePutChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StorePutChannel() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_StorePutChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreDeleteUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreDeleteUser() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_StoreDeleteUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreDeleteChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreDeleteChannel() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_StoreDeleteChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreLogout() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_StoreLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreLogoutByUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StoreLogoutByUser() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_StoreLogoutByUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Events() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Commands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Commands() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Commands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommands(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Write() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Register() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_RegisterCmd() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_RegisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterCmd(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Unregister() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnregisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UnregisterCmd() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UnregisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregisterCmd(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnregisterAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UnregisterAll() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_UnregisterAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregisterAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NetworkInformation() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_NetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetworkInformation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateSelf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateSelf() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_StateSelf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateSelf(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateUsers() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_StateUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateUsersByChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateUsersByChan() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_StateUsersByChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUsersByChan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateUsersByChanCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateUsersByChanCount() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_StateUsersByChanCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUsersByChanCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateUserModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateUserModes() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_StateUserModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateUserModes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateChannel() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_StateChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateChannels() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_StateChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateChannels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateChannelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateChannelCount() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_StateChannelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateChannelCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StateIsOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StateIsOn() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_StateIsOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStateIsOn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreAuthUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreAuthUser() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_StoreAuthUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreAuthUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreAuthedUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreAuthedUser() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_StoreAuthedUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreAuthedUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreUser() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_StoreUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreUsers() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_StoreUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreUsersByNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreUsersByNetwork() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_StoreUsersByNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUsersByNetwork(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreUsersByChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreUsersByChannel() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_StoreUsersByChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreUsersByChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreChannel() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_StoreChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreChannels() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_StoreChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreChannels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StorePutUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StorePutUser() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_StorePutUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStorePutUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StorePutChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StorePutChannel() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_StorePutChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStorePutChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreDeleteUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreDeleteUser() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_StoreDeleteUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreDeleteUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreDeleteChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreDeleteChannel() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_StoreDeleteChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreDeleteChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreLogout() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_StoreLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreLogout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreLogoutByUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StoreLogoutByUser() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_StoreLogoutByUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreLogoutByUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Events() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->Events(); }));
    }
    ~ExperimentalWithRawCallbackMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Events() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Commands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Commands() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->Commands(); }));
    }
    ~ExperimentalWithRawCallbackMethod_Commands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Commands() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Write() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Write(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Write(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Register() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Register(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Register(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RegisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_RegisterCmd() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->RegisterCmd(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_RegisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void RegisterCmd(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Unregister() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Unregister(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Unregister(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnregisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UnregisterCmd() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UnregisterCmd(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UnregisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UnregisterCmd(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnregisterAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UnregisterAll() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UnregisterAll(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UnregisterAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UnregisterAll(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NetworkInformation() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NetworkInformation(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NetworkInformation(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateSelf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateSelf() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateSelf(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateSelf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateSelf(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateUsers() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateUsers(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUsers(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateUsersByChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateUsersByChan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateUsersByChan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateUsersByChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUsersByChan(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateUsersByChanCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateUsersByChanCount() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateUsersByChanCount(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateUsersByChanCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUsersByChanCount(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateUserModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateUserModes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateUserModes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateUserModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateUserModes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateChannel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateChannel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateChannel(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateChannels() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateChannels(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateChannels(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateChannelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateChannelCount() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateChannelCount(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateChannelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateChannelCount(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StateIsOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StateIsOn() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StateIsOn(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StateIsOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StateIsOn(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreAuthUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreAuthUser() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreAuthUser(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreAuthUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreAuthUser(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreAuthedUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreAuthedUser() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreAuthedUser(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreAuthedUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreAuthedUser(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreUser() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreUser(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUser(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreUsers() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreUsers(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUsers(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreUsersByNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreUsersByNetwork() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreUsersByNetwork(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreUsersByNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUsersByNetwork(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreUsersByChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreUsersByChannel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreUsersByChannel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreUsersByChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreUsersByChannel(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreChannel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreChannel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreChannel(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreChannels() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreChannels(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreChannels(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StorePutUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StorePutUser() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StorePutUser(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StorePutUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StorePutUser(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StorePutChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StorePutChannel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StorePutChannel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StorePutChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StorePutChannel(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreDeleteUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreDeleteUser() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreDeleteUser(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreDeleteUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreDeleteUser(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreDeleteChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreDeleteChannel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(29,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreDeleteChannel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreDeleteChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreDeleteChannel(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreLogout() {
      ::grpc::Service::experimental().MarkMethodRawCallback(30,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreLogout(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreLogout(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreLogoutByUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreLogoutByUser() {
      ::grpc::Service::experimental().MarkMethodRawCallback(31,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreLogoutByUser(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreLogoutByUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreLogoutByUser(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Write() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::api::WriteRequest, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_Write<BaseClass>::StreamedWrite, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::api::WriteRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::WriteRequest,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Register() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::api::RegisterRequest, ::api::RegisterResponse>(std::bind(&WithStreamedUnaryMethod_Register<BaseClass>::StreamedRegister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Register(::grpc::ServerContext* context, const ::api::RegisterRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::RegisterRequest,::api::RegisterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RegisterCmd() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::api::RegisterCmdRequest, ::api::RegisterResponse>(std::bind(&WithStreamedUnaryMethod_RegisterCmd<BaseClass>::StreamedRegisterCmd, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RegisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterCmd(::grpc::ServerContext* context, const ::api::RegisterCmdRequest* request, ::api::RegisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterCmd(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::RegisterCmdRequest,::api::RegisterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unregister() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::api::UnregisterRequest, ::api::Result>(std::bind(&WithStreamedUnaryMethod_Unregister<BaseClass>::StreamedUnregister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnregister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::UnregisterRequest,::api::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnregisterCmd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UnregisterCmd() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::api::UnregisterRequest, ::api::Result>(std::bind(&WithStreamedUnaryMethod_UnregisterCmd<BaseClass>::StreamedUnregisterCmd, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UnregisterCmd() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnregisterCmd(::grpc::ServerContext* context, const ::api::UnregisterRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnregisterCmd(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::UnregisterRequest,::api::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnregisterAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UnregisterAll() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::api::UnregisterAllRequest, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_UnregisterAll<BaseClass>::StreamedUnregisterAll, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UnregisterAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnregisterAll(::grpc::ServerContext* context, const ::api::UnregisterAllRequest* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnregisterAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::UnregisterAllRequest,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NetworkInformation() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkInfoRequest, ::api::NetworkInfo>(std::bind(&WithStreamedUnaryMethod_NetworkInformation<BaseClass>::StreamedNetworkInformation, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NetworkInformation(::grpc::ServerContext* context, const ::api::NetworkInfoRequest* request, ::api::NetworkInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNetworkInformation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkInfoRequest,::api::NetworkInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateSelf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateSelf() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::SelfResponse>(std::bind(&WithStreamedUnaryMethod_StateSelf<BaseClass>::StreamedStateSelf, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateSelf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateSelf(::grpc::ServerContext* context, const ::api::Query* request, ::api::SelfResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateSelf(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::SelfResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateUsers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::StateUser>(std::bind(&WithStreamedUnaryMethod_StateUsers<BaseClass>::StreamedStateUsers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateUsers(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StateUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::StateUser>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateUsersByChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateUsersByChan() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::ListResponse>(std::bind(&WithStreamedUnaryMethod_StateUsersByChan<BaseClass>::StreamedStateUsersByChan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateUsersByChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateUsersByChan(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateUsersByChan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::ListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateUsersByChanCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateUsersByChanCount() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::CountResponse>(std::bind(&WithStreamedUnaryMethod_StateUsersByChanCount<BaseClass>::StreamedStateUsersByChanCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateUsersByChanCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateUsersByChanCount(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateUsersByChanCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::CountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateUserModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateUserModes() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::api::ChannelQuery, ::api::UserModes>(std::bind(&WithStreamedUnaryMethod_StateUserModes<BaseClass>::StreamedStateUserModes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateUserModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateUserModes(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::UserModes* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateUserModes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::ChannelQuery,::api::UserModes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateChannel() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::ChannelResponse>(std::bind(&WithStreamedUnaryMethod_StateChannel<BaseClass>::StreamedStateChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::ChannelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::ChannelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateChannels() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::ListResponse>(std::bind(&WithStreamedUnaryMethod_StateChannels<BaseClass>::StreamedStateChannels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateChannels(::grpc::ServerContext* context, const ::api::Query* request, ::api::ListResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateChannels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::ListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateChannelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateChannelCount() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::CountResponse>(std::bind(&WithStreamedUnaryMethod_StateChannelCount<BaseClass>::StreamedStateChannelCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateChannelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateChannelCount(::grpc::ServerContext* context, const ::api::Query* request, ::api::CountResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateChannelCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::CountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StateIsOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StateIsOn() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::api::ChannelQuery, ::api::Result>(std::bind(&WithStreamedUnaryMethod_StateIsOn<BaseClass>::StreamedStateIsOn, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StateIsOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StateIsOn(::grpc::ServerContext* context, const ::api::ChannelQuery* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStateIsOn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::ChannelQuery,::api::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreAuthUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreAuthUser() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::api::AuthUserRequest, ::api::Result>(std::bind(&WithStreamedUnaryMethod_StoreAuthUser<BaseClass>::StreamedStoreAuthUser, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreAuthUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreAuthUser(::grpc::ServerContext* context, const ::api::AuthUserRequest* request, ::api::Result* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreAuthUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::AuthUserRequest,::api::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreAuthedUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreAuthedUser() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::StoredUser>(std::bind(&WithStreamedUnaryMethod_StoreAuthedUser<BaseClass>::StreamedStoreAuthedUser, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreAuthedUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreAuthedUser(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreAuthedUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::StoredUser>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreUser() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::StoredUser>(std::bind(&WithStreamedUnaryMethod_StoreUser<BaseClass>::StreamedStoreUser, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUser* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::StoredUser>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreUsers() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Empty, ::api::StoredUsersResponse>(std::bind(&WithStreamedUnaryMethod_StoreUsers<BaseClass>::StreamedStoreUsers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreUsers(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Empty,::api::StoredUsersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreUsersByNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreUsersByNetwork() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::StoredUsersResponse>(std::bind(&WithStreamedUnaryMethod_StoreUsersByNetwork<BaseClass>::StreamedStoreUsersByNetwork, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreUsersByNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreUsersByNetwork(::grpc::ServerContext* context, const ::api::Query* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreUsersByNetwork(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::StoredUsersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreUsersByChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreUsersByChannel() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::StoredUsersResponse>(std::bind(&WithStreamedUnaryMethod_StoreUsersByChannel<BaseClass>::StreamedStoreUsersByChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreUsersByChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreUsersByChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredUsersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreUsersByChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::StoredUsersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreChannel() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::StoredChannel>(std::bind(&WithStreamedUnaryMethod_StoreChannel<BaseClass>::StreamedStoreChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::StoredChannel* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::StoredChannel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreChannels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreChannels() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Empty, ::api::StoredChannelsResponse>(std::bind(&WithStreamedUnaryMethod_StoreChannels<BaseClass>::StreamedStoreChannels, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreChannels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreChannels(::grpc::ServerContext* context, const ::api::Empty* request, ::api::StoredChannelsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreChannels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Empty,::api::StoredChannelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StorePutUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StorePutUser() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::api::StoredUser, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_StorePutUser<BaseClass>::StreamedStorePutUser, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StorePutUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StorePutUser(::grpc::ServerContext* context, const ::api::StoredUser* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStorePutUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::StoredUser,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StorePutChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StorePutChannel() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::api::StoredChannel, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_StorePutChannel<BaseClass>::StreamedStorePutChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StorePutChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StorePutChannel(::grpc::ServerContext* context, const ::api::StoredChannel* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStorePutChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::StoredChannel,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreDeleteUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreDeleteUser() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_StoreDeleteUser<BaseClass>::StreamedStoreDeleteUser, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreDeleteUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreDeleteUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreDeleteUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreDeleteChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreDeleteChannel() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_StoreDeleteChannel<BaseClass>::StreamedStoreDeleteChannel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreDeleteChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreDeleteChannel(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreDeleteChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreLogout() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::api::NetworkQuery, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_StoreLogout<BaseClass>::StreamedStoreLogout, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreLogout(::grpc::ServerContext* context, const ::api::NetworkQuery* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreLogout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::NetworkQuery,::api::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreLogoutByUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StoreLogoutByUser() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::api::Query, ::api::Empty>(std::bind(&WithStreamedUnaryMethod_StoreLogoutByUser<BaseClass>::StreamedStoreLogoutByUser, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreLogoutByUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreLogoutByUser(::grpc::ServerContext* context, const ::api::Query* request, ::api::Empty* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreLogoutByUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::Query,::api::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Write<WithStreamedUnaryMethod_Register<WithStreamedUnaryMethod_RegisterCmd<WithStreamedUnaryMethod_Unregister<WithStreamedUnaryMethod_UnregisterCmd<WithStreamedUnaryMethod_UnregisterAll<WithStreamedUnaryMethod_NetworkInformation<WithStreamedUnaryMethod_StateSelf<WithStreamedUnaryMethod_StateUsers<WithStreamedUnaryMethod_StateUsersByChan<WithStreamedUnaryMethod_StateUsersByChanCount<WithStreamedUnaryMethod_StateUserModes<WithStreamedUnaryMethod_StateChannel<WithStreamedUnaryMethod_StateChannels<WithStreamedUnaryMethod_StateChannelCount<WithStreamedUnaryMethod_StateIsOn<WithStreamedUnaryMethod_StoreAuthUser<WithStreamedUnaryMethod_StoreAuthedUser<WithStreamedUnaryMethod_StoreUser<WithStreamedUnaryMethod_StoreUsers<WithStreamedUnaryMethod_StoreUsersByNetwork<WithStreamedUnaryMethod_StoreUsersByChannel<WithStreamedUnaryMethod_StoreChannel<WithStreamedUnaryMethod_StoreChannels<WithStreamedUnaryMethod_StorePutUser<WithStreamedUnaryMethod_StorePutChannel<WithStreamedUnaryMethod_StoreDeleteUser<WithStreamedUnaryMethod_StoreDeleteChannel<WithStreamedUnaryMethod_StoreLogout<WithStreamedUnaryMethod_StoreLogoutByUser<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_Events() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::api::SubscriptionRequest, ::api::IRCEventResponse>(std::bind(&WithSplitStreamingMethod_Events<BaseClass>::StreamedEvents, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Events(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::IRCEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::SubscriptionRequest,::api::IRCEventResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_Commands : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_Commands() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::api::SubscriptionRequest, ::api::CmdEventResponse>(std::bind(&WithSplitStreamingMethod_Commands<BaseClass>::StreamedCommands, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_Commands() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Commands(::grpc::ServerContext* context, const ::api::SubscriptionRequest* request, ::grpc::ServerWriter< ::api::CmdEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCommands(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::SubscriptionRequest,::api::CmdEventResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Events<WithSplitStreamingMethod_Commands<Service > > SplitStreamedService;
  typedef WithSplitStreamingMethod_Events<WithSplitStreamingMethod_Commands<WithStreamedUnaryMethod_Write<WithStreamedUnaryMethod_Register<WithStreamedUnaryMethod_RegisterCmd<WithStreamedUnaryMethod_Unregister<WithStreamedUnaryMethod_UnregisterCmd<WithStreamedUnaryMethod_UnregisterAll<WithStreamedUnaryMethod_NetworkInformation<WithStreamedUnaryMethod_StateSelf<WithStreamedUnaryMethod_StateUsers<WithStreamedUnaryMethod_StateUsersByChan<WithStreamedUnaryMethod_StateUsersByChanCount<WithStreamedUnaryMethod_StateUserModes<WithStreamedUnaryMethod_StateChannel<WithStreamedUnaryMethod_StateChannels<WithStreamedUnaryMethod_StateChannelCount<WithStreamedUnaryMethod_StateIsOn<WithStreamedUnaryMethod_StoreAuthUser<WithStreamedUnaryMethod_StoreAuthedUser<WithStreamedUnaryMethod_StoreUser<WithStreamedUnaryMethod_StoreUsers<WithStreamedUnaryMethod_StoreUsersByNetwork<WithStreamedUnaryMethod_StoreUsersByChannel<WithStreamedUnaryMethod_StoreChannel<WithStreamedUnaryMethod_StoreChannels<WithStreamedUnaryMethod_StorePutUser<WithStreamedUnaryMethod_StorePutChannel<WithStreamedUnaryMethod_StoreDeleteUser<WithStreamedUnaryMethod_StoreDeleteChannel<WithStreamedUnaryMethod_StoreLogout<WithStreamedUnaryMethod_StoreLogoutByUser<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};
// ==================================
// Eventing/Pubsub methods
// ==================================

}  // namespace api


#endif  // GRPC_ultimateq_2eproto__INCLUDED
